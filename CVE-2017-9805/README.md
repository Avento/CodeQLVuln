# CVE-2017-9805 S2-052 CodeQL 查询

## 构建数据库

### 下载源码

下载这个[分支](https://github.com/apache/struts-examples/tree/8651c35385a9a228ff7dbe80bbc681d0e4de5e4e)（*8651c35*）下的 struts-examples，版本是 2.5.12。

### 编译环境

- Windows 10
- Apache Maven 3.5.3
- Java 1.8.0_102
- CodeQL  2.13.5

### 编译源码

我们只需要编译受漏洞影响的 `rest-angular` 即可。先直接编译以下看看是否有编译的问题，成功编译之后即可使用 CodeQL 建库了。

```bash
mvn clean package -pl :rest-angular -am -DskipTests
```

> 这里的 `-pl` 选项用于指定要构建的模块，`:rest-angular` 是使用 Struts 2 REST Plugin 的实例模块的名称。而 `-am` 选项会构建当前模块及其依赖模块。

### CodeQL 建库

```bash
codeql database create CVE-2017-9805-codeqlDB --language=java --command='mvn clean package -pl :rest-angular -am -DskipTests'
```

## CodeQL 查询

```codeql
/** 
* @kind path-problem 
*/
import java
import semmle.code.java.dataflow.TaintTracking
import DataFlow::PathGraph

/**  查找XML反序列化的地方，确定 sink 类似 x.fromXML(a,...) 的 a 的位置，使用需要传入一个 Expr，作为 fromXML 方法的第一个参数 */
predicate isXMLDeserialized(Expr arg) {
  exists(MethodAccess fromXML |
    fromXML.getMethod().getName() = "fromXML" and
    (arg = fromXML.getArgument(0))
  )
}

/** ContentTypeHandler 接口 */
/** The interface `org.apache.struts2.rest.handler.ContentTypeHandler`. */
class ContentTypeHandler extends RefType {
    ContentTypeHandler() {
      this.hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler")
    }
}

/** 找到 toObject 方法，并且这个方法所在的类是 ContentTypeHandler 接口的实现*/
/** A `toObject` method on a subtype of `org.apache.struts2.rest.handler.ContentTypeHandler`. */
class ContentTypeHandlerToObject extends Method {
    ContentTypeHandlerToObject() {
      this.getDeclaringType().getASupertype() instanceof ContentTypeHandler and
      this.hasName("toObject")
    }
}

/** 污点跟踪配置类 */
/** x.toObject(a,...) -> ... -> y.fromXML(a,...) */
class StrutsUnsafeDeserializationConfig extends TaintTracking::Configuration {
    StrutsUnsafeDeserializationConfig() { this = "StrutsUnsafeDeserializationConfig" }

    /** toObject 方法 的第一个参数作为 source */
    override predicate isSource(DataFlow::Node source) {
        exists(ContentTypeHandlerToObject toObjectMethod  |
            source.asParameter() = toObjectMethod.getParameter(0)
        )
    }
    /** fromXML 方法的第一个参数作为 sink */
    override predicate isSink(DataFlow::Node sink) {
        exists(Expr arg |
            isXMLDeserialized(arg) and
            sink.asExpr() = arg
        )
    }
}

/** 固定查询 FlowPath 的查询格式 */
from StrutsUnsafeDeserializationConfig cfg, DataFlow::PathNode source, DataFlow::PathNode sink
where cfg.hasFlowPath(source, sink)
select sink, source, sink, "Custom constraint error message contains unsanitized user data"
```

## 漏洞复现

上面建库完成后，将 `\struts-examples\rest-angular\target\rest-angular-1.0.0.war` 复制到 Tocmat 的 webapps，参考 [vulhub/struts2/s2-052](https://github.com/vulhub/vulhub/tree/c8121bc2ee1e5bc8607a7e04681f77cce9105b58/struts2/s2-052#s2-052-remote-code-execution-vulnerablity) 即可复现漏洞。

## 源码调试

这里我们需要的是从

