/** 
* @kind path-problem 
*/
import java
import semmle.code.java.dataflow.TaintTracking
import DataFlow::PathGraph

/**  查找XML反序列化的地方，确定 sink 类似 x.fromXML(a,...) 的 a 的位置，使用需要传入一个 Expr，作为 fromXML 方法的第一个参数 */
predicate isXMLDeserialized(Expr arg) {
  exists(MethodAccess fromXML |
    fromXML.getMethod().getName() = "fromXML" and
    (arg = fromXML.getArgument(0))
  )
}

/** ContentTypeHandler 接口 */
/** The interface `org.apache.struts2.rest.handler.ContentTypeHandler`. */
class ContentTypeHandler extends RefType {
    ContentTypeHandler() {
      this.hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler")
    }
}

/** 找到 toObject 方法，并且这个方法所在的类是 ContentTypeHandler 接口的实现*/
/** A `toObject` method on a subtype of `org.apache.struts2.rest.handler.ContentTypeHandler`. */
class ContentTypeHandlerToObject extends Method {
    ContentTypeHandlerToObject() {
      this.getDeclaringType().getASupertype() instanceof ContentTypeHandler and
      this.hasName("toObject")
    }
}

/** 污点跟踪配置类 */
/** x.toObject(a,...) -> ... -> y.fromXML(a,...) */
class StrutsUnsafeDeserializationConfig extends TaintTracking::Configuration {
    StrutsUnsafeDeserializationConfig() { this = "StrutsUnsafeDeserializationConfig" }

    /** toObject 方法 的第一个参数作为 source */
    override predicate isSource(DataFlow::Node source) {
        exists(ContentTypeHandlerToObject toObjectMethod  |
            source.asParameter() = toObjectMethod.getParameter(0)
        )
    }
    /** fromXML 方法的第一个参数作为 sink */
    override predicate isSink(DataFlow::Node sink) {
        exists(Expr arg |
            isXMLDeserialized(arg) and
            sink.asExpr() = arg
        )
    }
}

/** 固定查询 FlowPath 的查询格式 */
from StrutsUnsafeDeserializationConfig cfg, DataFlow::PathNode source, DataFlow::PathNode sink
where cfg.hasFlowPath(source, sink)
select sink, source, sink, "Custom constraint error message contains unsanitized user data"